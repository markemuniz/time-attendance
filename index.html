<!DOCTYPE html>
<html lang="en">
<head><link rel="icon" type="image/png" href="favicon.png">
</head>
<meta charset="UTF-8">
<title>The Travel Agency Attendance Report</title>
<style>
/* Global styles */
body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f5f7fa;
    color: #333;
}

/* Container styling */
.container {
    max-width: 1200px;
    margin: 20px auto;
    background-color: #fff;
    padding: 20px 30px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* Title styling */
.title {
    margin: 0 0 20px;
    font-size: 28px;
    text-align: center;
    color: #2c3e50;
}

/* Controls styling */
.controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    align-items: flex-end;
    margin-bottom: 20px;
}

.control-group {
    display: flex;
    flex-direction: column;
}

.control-label {
    margin-bottom: 4px;
    font-weight: 600;
}

.control-input,
.control-select,
.control-button {
    padding: 6px 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
}

.control-select:disabled,
.control-button:disabled,
.control-input:disabled {
    background-color: #eee;
    cursor: not-allowed;
}

.control-button {
    background-color: #007bff;
    color: #fff;
    border: none;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.control-button:hover:not(:disabled) {
    background-color: #0056b3;
}

/* Table styling */
.table-container {
    overflow-x: auto;
}

table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 10px;
    min-width: 600px;
}

th, td {
    padding: 10px;
    text-align: left;
    border-bottom: 1px solid #e1e4e8;
}

th {
    background-color: #f0f2f5;
    font-weight: 600;
    color: #333;
}

tr:nth-child(even) {
    background-color: #fafafa;
}

tr:hover {
    background-color: #f5f5f5;
}

/* Status styling */
.status-call_out {
    color: #c0392b;
    font-weight: 600;
}

.status-tardy {
    color: #e67e22;
    font-weight: 600;
}

/* Summary styling */
.summary {
    font-weight: 600;
    margin-top: 10px;
    color: #2c3e50;
}
</style>
</head>
<body>
<div class="container">
    <h1 class="title">The Travel Agency Attendance</h1>
    <div class="controls">
        <div class="control-group">
            <label for="fileInput" class="control-label">Upload Report:</label>
            <input type="file" id="fileInput" accept=".csv,.xlsx,.xls" class="control-input">
        </div>
        <div class="control-group">
            <label for="nameSelect" class="control-label">Employee:</label>
            <select id="nameSelect" disabled class="control-select"><option value="all">All</option></select>
        </div>
        <div class="control-group">
            <label for="dateSelect" class="control-label">Date:</label>
            <select id="dateSelect" disabled class="control-select"><option value="all">All</option></select>
        </div>
        <div class="control-group">
            <button id="clearBtn" disabled class="control-button">Clear Saved Data</button>
        </div>
    </div>
    <div class="table-container">
        <table id="reportTable">
            <thead>
                <tr>
                    <th>Date</th>
                    <th>Name</th>
                    <th>Scheduled Shift</th>
                    <th>Clock In</th>
                    <th>Minutes Late</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="summary" class="summary"></div>
</div>

<!-- Include SheetJS library for Excel parsing -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
// In-memory dataset; persisted via localStorage
let dataset = [];

// Load dataset from localStorage if available
function loadDataset() {
    const saved = localStorage.getItem('attendanceDataset');
    if (saved) {
        try {
            const parsed = JSON.parse(saved);
            if (Array.isArray(parsed)) dataset = parsed;
            // For backward compatibility: migrate old dataset entries lacking new fields.
            dataset.forEach(item => {
                // Convert legacy status field into callOut/tardyFlag fields if present.
                if (item.status) {
                    if (item.status === 'call_out') item.callOut = true;
                    if (item.status === 'tardy') item.tardyFlag = true;
                    delete item.status;
                }
                // Derive callOut if missing.
                if (item.callOut === undefined) {
                    const shift = item.shiftTime || '';
                    // Prefer rawClockTime if present; fallback to clockTime for legacy rows.
                    const clock = item.rawClockTime !== undefined ? item.rawClockTime : (item.clockTime || '');
                    item.callOut = (clock === '' && shift !== '');
                }
                // Provide default type if missing.
                if (item.type === undefined) item.type = '';
                // Ensure tardyFlag is boolean.
                if (item.tardyFlag === undefined) item.tardyFlag = false;
                // Migrate legacy fields to new rawClockTime/rawDiffMinutes and isClockInType when absent.
                if (item.rawClockTime === undefined) item.rawClockTime = item.clockTime !== undefined ? item.clockTime : '';
                if (item.rawDiffMinutes === undefined) item.rawDiffMinutes = item.diffMinutes !== undefined ? item.diffMinutes : null;
                if (item.isClockInType === undefined) {
                    // Determine isClockInType based on type string if available; if not, assume true when clockTime exists.
                    item.isClockInType = item.type ? /clock\-?in/i.test(item.type) : (item.rawClockTime !== '');
                }
            });
        } catch (e) {
            console.warn('Failed to parse saved dataset:', e);
        }
    }
}

// Save dataset to localStorage
function saveDataset() {
    try {
        localStorage.setItem('attendanceDataset', JSON.stringify(dataset));
    } catch (e) {
        console.warn('Unable to save dataset:', e);
    }
}

function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        if (inQuotes) {
            if (char === '"') {
                if (i + 1 < line.length && line[i+1] === '"') { current += '"'; i++; }
                else { inQuotes = false; }
            } else { current += char; }
        } else {
            if (char === '"') inQuotes = true;
            else if (char === ',') { result.push(current); current = ''; }
            else current += char;
        }
    }
    result.push(current);
    return result;
}

function parseCSV(content) {
    let lines = content.replace(/\r/g, '').split('\n');
    lines = lines.filter(l => l.trim() !== '');
    if (lines.length === 0) return [];
    const header = parseCSVLine(lines[0]);
    const rows = [];
    for (let i = 1; i < lines.length; i++) {
        const fields = parseCSVLine(lines[i]);
        if (fields.length !== header.length) continue;
        const row = {};
        for (let j = 0; j < header.length; j++) { row[header[j]] = fields[j]; }
        rows.push(row);
    }
    return rows;
}

function convertRow(row) {
    /*
     * Convert a raw CSV/Excel row into our internal object. We preserve the
     * original clock time and lateness minutes to support recalculation of
     * display values on the fly. A "clock-in" event is determined by the
     * `Type` column containing the substring "clock-in"; clock‑out events and
     * other types (e.g. breaks) are treated separately. Lateness minutes are
     * only relevant for clock‑ins. Call‑outs occur when a shift is scheduled
     * but no clock in time is recorded.
     */
    function toISO(dateStr) {
        const d = new Date(dateStr);
        return isNaN(d) ? dateStr : d.toISOString().slice(0,10);
    }
    const shift = row['Shift Time'] || '';
    let shiftStart = '', shiftEnd = '';
    if (shift.includes(' - ')) {
        const parts = shift.split(' - ');
        shiftStart = parts[0].trim();
        shiftEnd = parts[1].trim();
    }
    // Keep the raw clock value from the data. It may be empty (no show), a clock-in, or a clock-out time.
    const rawClock = row['Clock In/Out Time'] || '';
    // Extract the numeric portion of the Late/Early field (e.g., "14 minutes" -> 14). If absent, set to null.
    let rawDiff = null;
    const lateEarly = row['Late/Early'] || '';
    if (lateEarly) {
        const m = lateEarly.match(/(-?\d+)/);
        if (m) rawDiff = parseInt(m[1], 10);
    }
    // Normalise type for easier comparison.
    const type = row['Type'] || '';
    const isClockInType = /clock\-?in/i.test(type);
    // A call‑out means a shift start time exists but there is no clock recorded.
    const callOut = (rawClock === '' && shiftStart !== '');
    // Determine if this is a late clock-in of >=8 minutes.
    let tardyFlag = false;
    if (isClockInType && rawDiff != null && rawDiff >= 8) {
        tardyFlag = true;
    }
    return {
        date: toISO(row['Date']),
        name: row['Name'] || '',
        shiftTime: shift,
        // Preserve raw values for later calculations.
        rawClockTime: rawClock,
        rawDiffMinutes: rawDiff,
        type: type,
        isClockInType: isClockInType,
        callOut: callOut,
        tardyFlag: tardyFlag
    };
}

function populateDropdowns() {
    const nameSelect = document.getElementById('nameSelect');
    const dateSelect = document.getElementById('dateSelect');
    const names = new Set();
    const dates = new Set();
    dataset.forEach(item => { names.add(item.name); dates.add(item.date); });
    nameSelect.innerHTML = '<option value="all">All</option>';
    dateSelect.innerHTML = '<option value="all">All</option>';
    Array.from(names).sort().forEach(n => { const opt = document.createElement('option'); opt.value = n; opt.textContent = n; nameSelect.appendChild(opt); });
    Array.from(dates).sort().forEach(d => { const opt = document.createElement('option'); opt.value = d; opt.textContent = d; dateSelect.appendChild(opt); });
    nameSelect.disabled = false;
    dateSelect.disabled = false;
    document.getElementById('clearBtn').disabled = dataset.length === 0;
}

function render() {
    const nameSel = document.getElementById('nameSelect').value;
    const dateSel = document.getElementById('dateSelect').value;
    const tbody = document.getElementById('reportTable').getElementsByTagName('tbody')[0];
    tbody.innerHTML = '';
    // Filter by name and date. When a specific date is selected, include all records
    // on or after that date rather than matching only that exact date.
    const filtered = dataset.filter(item => {
        const matchName = nameSel === 'all' || item.name === nameSel;
        let matchDate = true;
        if (dateSel !== 'all') {
            // Compare ISO date strings lexicographically; earlier dates have smaller strings
            matchDate = item.date >= dateSel;
        }
        return matchName && matchDate;
    });
    filtered.sort((a,b) => { if (a.date < b.date) return -1; if (a.date > b.date) return 1; if (a.name < b.name) return -1; if (a.name > b.name) return 1; return 0; });
    let tardyCount = 0;
    let callOutCount = 0;
    filtered.forEach(item => {
        /*
         * For each row, determine whether it represents a call‑out or a tardy. We
         * only display rows that have a tardy or call‑out status; on‑time
         * employees are omitted. The display values are calculated so that
         * clock‑out entries are blank.
         */
        const displayClock = item.isClockInType ? (item.rawClockTime || '') : '';
        const displayDiff = item.isClockInType ? (item.rawDiffMinutes != null ? item.rawDiffMinutes : '') : '';
        // Determine call‑out: shift scheduled but no clock‑in
        const callOut = (item.callOut !== undefined) ? item.callOut : (item.rawClockTime === '' && item.shiftTime !== '');
        // Determine tardy for clock‑ins
        let tardy;
        if (item.tardyFlag !== undefined) {
            tardy = item.tardyFlag;
        } else {
            tardy = item.isClockInType && item.rawDiffMinutes != null && item.rawDiffMinutes >= 8;
        }
        // Update counts
        if (callOut) {
            callOutCount++;
        } else if (tardy) {
            tardyCount++;
        }
        // Only display rows that are call‑outs or tardies. Skip on‑time/early clock‑ins and all other entries.
        if (!callOut && !tardy) {
            return;
        }
        const statusStr = callOut ? 'Call Out' : 'Tardy';
        const statusClass = callOut ? 'status-call_out' : 'status-tardy';
        const tr = document.createElement('tr');
        tr.innerHTML = '<td>' + item.date + '</td>' +
                       '<td>' + item.name + '</td>' +
                       '<td>' + item.shiftTime + '</td>' +
                       '<td>' + displayClock + '</td>' +
                       '<td>' + displayDiff + '</td>' +
                       '<td class="' + statusClass + '">' + statusStr + '</td>';
        tbody.appendChild(tr);
    });
    const summaryElem = document.getElementById('summary');
    if (nameSel !== 'all' || dateSel !== 'all') { summaryElem.textContent = 'Tardies: ' + tardyCount + ', Call Outs: ' + callOutCount; } else summaryElem.textContent = '';
}

function handleFile(file) {
    const ext = file.name.split('.').pop().toLowerCase();
    if (ext === 'csv') {
        const reader = new FileReader();
        reader.onload = e => {
            const content = e.target.result;
            const rows = parseCSV(content);
            const newData = rows.map(r => convertRow(r));
            dataset = dataset.concat(newData);
            saveDataset();
            populateDropdowns();
            render();
            alert('Loaded ' + newData.length + ' records from CSV. Total records: ' + dataset.length);
        };
        reader.readAsText(file);
    } else if (ext === 'xlsx' || ext === 'xls') {
        const reader = new FileReader();
        reader.onload = e => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(sheet, { defval: '' });
            const newData = json.map(r => convertRow(r));
            dataset = dataset.concat(newData);
            saveDataset();
            populateDropdowns();
            render();
            alert('Loaded ' + newData.length + ' records from Excel sheet ' + sheetName + '. Total records: ' + dataset.length);
        };
        reader.readAsArrayBuffer(file);
    } else { alert('Unsupported file type: ' + ext); }
}

// Clear the saved dataset
function clearData() {
    if (confirm('Are you sure you want to clear all saved attendance data?')) {
        dataset = [];
        saveDataset();
        populateDropdowns();
        render();
    }
}

// Event listeners
document.getElementById('fileInput').addEventListener('change', () => {
    const file = document.getElementById('fileInput').files[0];
    if (file) handleFile(file);
});

document.getElementById('nameSelect').addEventListener('change', render);
document.getElementById('dateSelect').addEventListener('change', render);
document.getElementById('clearBtn').addEventListener('click', clearData);

// On page load: load dataset and initialize
window.addEventListener('DOMContentLoaded', () => {
    loadDataset();
    populateDropdowns();
    render();
});
</script>
</body>
</html>
